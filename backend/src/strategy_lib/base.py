"""
Base Strategy Interface

This module defines the abstract base class and interfaces that all trading strategies
must implement. It provides a consistent API for both backtesting and live trading,
with support for multi-symbol strategies and flexible signal generation.
"""

from abc import ABC, abstractmethod
from datetime import datetime, timezone
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union, Set
from enum import Enum
import pandas as pd
import logging

from pydantic import BaseModel, Field, validator
from common.schemas import SignalType, OrderSide


class StrategyState(str, Enum):
    """Strategy execution state."""
    INITIALIZING = "initializing"
    RUNNING = "running"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"


class SignalStrength(str, Enum):
    """Predefined signal strength levels."""
    WEAK = "0.25"
    MODERATE = "0.50"
    STRONG = "0.75"
    VERY_STRONG = "1.00"


class StrategySignal(BaseModel):
    """
    Strategy signal output.
    
    This represents a trading signal generated by a strategy, which can be
    used for both backtesting and live trading.
    """
    symbol: str = Field(..., description="Trading symbol")
    signal_type: SignalType = Field(..., description="Signal type (BUY/SELL/HOLD/EXIT)")
    strength: Optional[Decimal] = Field(None, description="Signal strength (0.0-1.0)")
    price: Optional[Decimal] = Field(None, description="Suggested execution price")
    quantity: Optional[int] = Field(None, description="Suggested position size")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional signal metadata")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    @validator('strength')
    def validate_strength(cls, v):
        if v is not None and (v < 0 or v > 1):
            raise ValueError('Signal strength must be between 0.0 and 1.0')
        return v
    
    class Config:
        use_enum_values = True


class StrategyConfig(BaseModel):
    """
    Strategy configuration and parameters.
    
    This is the base configuration class that all strategies should extend
    with their specific parameters.
    """
    strategy_id: str = Field(..., description="Unique strategy identifier")
    name: str = Field(..., description="Human-readable strategy name")
    symbols: List[str] = Field(..., description="List of symbols to trade")
    enabled: bool = Field(default=False, description="Whether strategy is enabled")
    
    # Risk management parameters
    max_position_size: Optional[int] = Field(None, description="Maximum position size per symbol")
    max_total_exposure: Optional[Decimal] = Field(None, description="Maximum total dollar exposure")
    stop_loss_pct: Optional[Decimal] = Field(None, description="Stop loss percentage (0.0-1.0)")
    take_profit_pct: Optional[Decimal] = Field(None, description="Take profit percentage (0.0-1.0)")
    
    # Timing parameters
    bar_timeframe: str = Field(default="1 min", description="Bar timeframe for strategy execution")
    lookback_periods: int = Field(default=50, description="Number of historical bars to provide")
    
    # Strategy-specific parameters (to be extended by subclasses)
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Strategy-specific parameters")
    
    class Config:
        extra = "allow"  # Allow additional fields for strategy-specific params


class StrategyMetrics(BaseModel):
    """Strategy performance metrics."""
    total_signals: int = 0
    successful_signals: int = 0
    total_pnl: Decimal = Decimal('0.0')
    win_rate: Optional[Decimal] = None
    avg_signal_strength: Optional[Decimal] = None
    last_signal_time: Optional[datetime] = None
    errors_count: int = 0
    
    def update_win_rate(self):
        """Calculate and update win rate."""
        if self.total_signals > 0:
            self.win_rate = Decimal(self.successful_signals) / Decimal(self.total_signals)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This class defines the interface that all strategies must implement.
    It supports both single-symbol and multi-symbol strategies, with
    flexible parameter management and signal generation.
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize strategy with configuration.
        
        Args:
            config: Strategy configuration containing parameters and settings
        """
        self.config = config
        self.state = StrategyState.INITIALIZING
        self.logger = logging.getLogger(f"strategy.{config.strategy_id}")
        self.metrics = StrategyMetrics()
        self._positions: Dict[str, int] = {}  # Track current positions
        self._last_prices: Dict[str, Decimal] = {}  # Track last known prices
        
        # Validate configuration
        self._validate_config()
    
    def _validate_config(self):
        """Validate strategy configuration."""
        if not self.config.symbols:
            raise ValueError("Strategy must specify at least one symbol")
        
        if self.config.max_position_size is not None and self.config.max_position_size <= 0:
            raise ValueError("max_position_size must be positive")
            
        if self.config.lookback_periods <= 0:
            raise ValueError("lookback_periods must be positive")
    
    @abstractmethod
    async def on_start(self, instruments: Dict[str, Any]) -> None:
        """
        Initialize strategy when starting.
        
        This method is called once when the strategy is first started.
        Use it to initialize any state, load historical data, or set up
        indicators.
        
        Args:
            instruments: Dictionary of symbol -> contract information
        """
        pass
    
    @abstractmethod
    async def on_bar(self, symbol: str, timeframe: str, bars: pd.DataFrame) -> List[StrategySignal]:
        """
        Process new bar data and generate signals.
        
        This is the main strategy logic method, called whenever new bar data
        is available for any of the strategy's symbols.
        
        Args:
            symbol: The symbol for which new data is available
            timeframe: The timeframe of the bars (e.g., "1 min", "5 mins")
            bars: DataFrame with OHLCV data, sorted by timestamp ascending
                  Columns: ['timestamp', 'open', 'high', 'low', 'close', 'volume']
                  Last row contains the most recent complete bar
        
        Returns:
            List of StrategySignal objects (can be empty if no signals)
        """
        pass
    
    @abstractmethod
    async def on_stop(self) -> None:
        """
        Cleanup when strategy is stopping.
        
        This method is called when the strategy is being stopped.
        Use it to close positions, save state, or perform cleanup.
        """
        pass
    
    # Optional lifecycle methods that strategies can override
    
    async def on_signal_executed(self, signal: StrategySignal, success: bool, 
                                execution_price: Optional[Decimal] = None) -> None:
        """
        Called when a signal has been executed (or failed to execute).
        
        Args:
            signal: The original signal that was executed
            success: Whether the execution was successful
            execution_price: Actual execution price (if successful)
        """
        self.metrics.total_signals += 1
        if success:
            self.metrics.successful_signals += 1
            if execution_price and signal.symbol in self._last_prices:
                # Update position tracking
                if signal.signal_type == SignalType.BUY:
                    self._positions[signal.symbol] = self._positions.get(signal.symbol, 0) + (signal.quantity or 0)
                elif signal.signal_type == SignalType.SELL:
                    self._positions[signal.symbol] = self._positions.get(signal.symbol, 0) - (signal.quantity or 0)
        else:
            self.metrics.errors_count += 1
        
        self.metrics.update_win_rate()
        self.metrics.last_signal_time = datetime.now(timezone.utc)
    
    async def on_tick(self, symbol: str, tick_data: Dict[str, Any]) -> None:
        """
        Called when new tick data is available (optional).
        
        Most strategies will use on_bar() instead, but this is available
        for high-frequency strategies that need tick-level data.
        
        Args:
            symbol: Symbol for the tick data
            tick_data: Dictionary with tick information (bid, ask, last, etc.)
        """
        # Update last known prices
        if 'last' in tick_data and tick_data['last'] is not None:
            self._last_prices[symbol] = Decimal(str(tick_data['last']))
    
    async def on_parameter_update(self, new_params: Dict[str, Any]) -> None:
        """
        Called when strategy parameters are updated (hot reload).
        
        Args:
            new_params: Dictionary of updated parameters
        """
        # Update config parameters
        for key, value in new_params.items():
            if hasattr(self.config, key):
                setattr(self.config, key, value)
            else:
                self.config.parameters[key] = value
        
        self.logger.info(f"Parameters updated: {new_params}")
    
    # Utility methods for strategies
    
    def get_position(self, symbol: str) -> int:
        """Get current position for a symbol."""
        return self._positions.get(symbol, 0)
    
    def get_last_price(self, symbol: str) -> Optional[Decimal]:
        """Get last known price for a symbol."""
        return self._last_prices.get(symbol)
    
    def is_long(self, symbol: str) -> bool:
        """Check if currently long a symbol."""
        return self.get_position(symbol) > 0
    
    def is_short(self, symbol: str) -> bool:
        """Check if currently short a symbol."""
        return self.get_position(symbol) < 0
    
    def is_flat(self, symbol: str) -> bool:
        """Check if flat (no position) in a symbol."""
        return self.get_position(symbol) == 0
    
    def create_signal(self, symbol: str, signal_type: SignalType, 
                     strength: Optional[Union[Decimal, float, str]] = None,
                     price: Optional[Union[Decimal, float]] = None,
                     quantity: Optional[int] = None,
                     **metadata) -> StrategySignal:
        """
        Helper method to create a properly formatted signal.
        
        Args:
            symbol: Trading symbol
            signal_type: Type of signal (BUY/SELL/HOLD/EXIT)
            strength: Signal strength (0.0-1.0)
            price: Suggested execution price
            quantity: Suggested position size
            **metadata: Additional metadata to include
        
        Returns:
            StrategySignal object
        """
        # Convert strength to Decimal if provided
        if strength is not None:
            if isinstance(strength, str) and strength in SignalStrength.__members__.values():
                strength = Decimal(strength)
            else:
                strength = Decimal(str(strength))
        
        # Convert price to Decimal if provided
        if price is not None:
            price = Decimal(str(price))
        
        # Add strategy metadata
        metadata.update({
            'strategy_id': self.config.strategy_id,
            'strategy_name': self.config.name,
            'current_position': self.get_position(symbol),
            'last_price': str(self.get_last_price(symbol)) if self.get_last_price(symbol) else None
        })
        
        return StrategySignal(
            symbol=symbol,
            signal_type=signal_type,
            strength=strength,
            price=price,
            quantity=quantity,
            metadata=metadata
        )
    
    def log_info(self, message: str, **kwargs):
        """Log info message with strategy context."""
        self.logger.info(f"[{self.config.strategy_id}] {message}", extra=kwargs)
    
    def log_warning(self, message: str, **kwargs):
        """Log warning message with strategy context."""
        self.logger.warning(f"[{self.config.strategy_id}] {message}", extra=kwargs)
    
    def log_error(self, message: str, **kwargs):
        """Log error message with strategy context."""
        self.logger.error(f"[{self.config.strategy_id}] {message}", extra=kwargs)
    
    def get_metrics(self) -> StrategyMetrics:
        """Get current strategy metrics."""
        return self.metrics
    
    def get_state(self) -> StrategyState:
        """Get current strategy state."""
        return self.state
    
    def set_state(self, state: StrategyState):
        """Set strategy state."""
        old_state = self.state
        self.state = state
        self.log_info(f"State changed: {old_state} -> {state}")


# Utility functions for strategy development

def validate_bars_dataframe(bars: pd.DataFrame) -> bool:
    """
    Validate that a bars DataFrame has the expected structure.
    
    Args:
        bars: DataFrame to validate
        
    Returns:
        True if valid, False otherwise
    """
    required_columns = {'timestamp', 'open', 'high', 'low', 'close', 'volume'}
    
    if not isinstance(bars, pd.DataFrame):
        return False
    
    if not required_columns.issubset(set(bars.columns)):
        return False
    
    if bars.empty:
        return False
    
    # Check for proper timestamp ordering
    if not bars['timestamp'].is_monotonic_increasing:
        return False
    
    return True


def calculate_position_size(signal_strength: Decimal, max_position: int, 
                          current_position: int = 0) -> int:
    """
    Calculate position size based on signal strength and risk limits.
    
    Args:
        signal_strength: Signal strength (0.0-1.0)
        max_position: Maximum allowed position size
        current_position: Current position (for position sizing)
        
    Returns:
        Suggested position size
    """
    if signal_strength <= 0:
        return 0
    
    # Scale position size by signal strength
    target_size = int(max_position * float(signal_strength))
    
    # Ensure we don't exceed maximum position
    target_size = min(target_size, max_position)
    
    # Calculate the change needed from current position
    position_change = target_size - current_position
    
    return abs(position_change)


def format_currency(value: Union[Decimal, float], currency: str = "USD") -> str:
    """Format a currency value for display."""
    if isinstance(value, float):
        value = Decimal(str(value))
    
    return f"{value:,.2f} {currency}"


def format_percentage(value: Union[Decimal, float], decimals: int = 2) -> str:
    """Format a percentage value for display."""
    if isinstance(value, float):
        value = Decimal(str(value))
    
    percentage = value * 100
    return f"{percentage:.{decimals}f}%"
